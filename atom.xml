<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一心向阳</title>
  
  <subtitle>心之所向，必有奇迹</subtitle>
  <link href="https://jiajunlen.github.io/atom.xml" rel="self"/>
  
  <link href="https://jiajunlen.github.io/"/>
  <updated>2024-03-20T08:38:18.663Z</updated>
  <id>https://jiajunlen.github.io/</id>
  
  <author>
    <name>len</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>socket-base-learn</title>
    <link href="https://jiajunlen.github.io/post/socket/"/>
    <id>https://jiajunlen.github.io/post/socket/</id>
    <published>2024-03-13T08:37:06.000Z</published>
    <updated>2024-03-20T08:38:18.663Z</updated>
    
    <content type="html"><![CDATA[<p>xue</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;xue&lt;/p&gt;
</summary>
      
    
    
    
    <category term="网络编程" scheme="https://jiajunlen.github.io/category/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C/C++;socket" scheme="https://jiajunlen.github.io/tag/C-C-socket/"/>
    
  </entry>
  
  <entry>
    <title>STL</title>
    <link href="https://jiajunlen.github.io/post/stlbase/"/>
    <id>https://jiajunlen.github.io/post/stlbase/</id>
    <published>2024-03-13T07:14:11.000Z</published>
    <updated>2024-03-13T08:36:26.142Z</updated>
    
    <content type="html"><![CDATA[<p>STL(Standard Template Library)：标模板库</p><p>广义：容器(container)、算法(algorithm)、迭代器(iterator)</p><p>容器和算法之间通过迭代器无缝衔接</p><p>STL几乎所有源码采用模板类或者模板函数</p><h1 id="1、STL六大组件"><a href="#1、STL六大组件" class="headerlink" title="1、STL六大组件"></a>1、STL六大组件</h1><p>容器、算法、迭代器、仿函数、适配器(配接器)、空间配置器</p><p>（1）容器：各种数据结构，如vector、list、deque、set、map等，用于存放数据<br>（2）算法：各种常用算法，如sort、find、copy、for_each等<br>（3）迭代器：容器与算法之间的粘合剂<br>（4）仿函数：行为类似函数，可作为算法的某种策略<br>（5）适配器：一种用来修饰容器或者仿函数或迭代器接口的东西<br>（6）空间配置器：负责空间的配置与管理</p><h2 id="1、容器算法迭代器"><a href="#1、容器算法迭代器" class="headerlink" title="1、容器算法迭代器"></a>1、容器算法迭代器</h2><h3 id="1-1-容器"><a href="#1-1-容器" class="headerlink" title="1.1 容器"></a>1.1 容器</h3><p>常用的数据结构：数组、链表、树、栈、队列、集合、映射表等</p><p><strong>序列式容器：</strong>强调值的排序，每个元素位置固定；<br><strong>关联式容器：</strong>二叉树结构，各元素之间无严格物理顺序关系</p><h3 id="1-2-算法"><a href="#1-2-算法" class="headerlink" title="1.2 算法"></a>1.2 算法</h3><p>Algorithm</p><p><strong>质变算法：</strong>运算过程中会更改区间内元素的内容。如：拷贝、替换、删除等等；<br><strong>非质变算法：</strong>运算过程中不会更改区间内的元素内容。如：查找、计数、遍历、寻找极值等等。</p><h3 id="1-3-迭代器"><a href="#1-3-迭代器" class="headerlink" title="1.3 迭代器"></a>1.3 迭代器</h3><p>提供一种方法，使能够依序寻访某个容器所包含的各个元素，而又无需暴露该容器的内部表示方式。</p><p>每个容器都有自己专属迭代器</p><p><strong>迭代器种类</strong></p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++、–、！&#x3D;</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++、&#x3D;&#x3D;、！&#x3D;</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持++、–</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持++、–、[n]、-n、&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;</td></tr></tbody></table><p><strong>常用：</strong>双向、随机</p><h3 id="1-4-使用"><a href="#1-4-使用" class="headerlink" title="1.4 使用"></a>1.4 使用</h3><p>STL中最常用的容器vector,理解为数组</p><h4 id="1-4-1-vector"><a href="#1-4-1-vector" class="headerlink" title="1.4.1 vector"></a>1.4.1 vector</h4><p><strong>容器：</strong>  <code>vector</code><br><strong>算法：</strong>  <code>for_each</code><br><strong>迭代器：</strong><code>vector&lt;int&gt;::iterator</code></p><p><strong>实例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line">#include&lt;algorithm&gt; // 标准算法头文件</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void vPrint(int val)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; v;</span><br><span class="line">    v.push_back(10);</span><br><span class="line">    v.push_back(20);</span><br><span class="line">    v.push_back(30);</span><br><span class="line">    v.push_back(40);</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt;::iterator itBegin = v.begin(); //起始迭代器，指向容器第一个元素</span><br><span class="line">    vector&lt;int&gt;::iterator itEnd = v.end(); //结束迭代器，指向容器中最后一个元素的下一个位置</span><br><span class="line">    // 第一种遍历方式</span><br><span class="line">    while(itBegin != itEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *itBegin &lt;&lt; endl;</span><br><span class="line">        itBegin++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 第二种遍历方式</span><br><span class="line">    for(vector&lt;int&gt;::iteator it = v.begin(); it != v.end(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 第三种遍历方式  利用STL提供遍历算法,头文件algorithm</span><br><span class="line">    for_each(v.begin(),v.end(),vPrint); // vPrint利用回调函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;STL(Standard Template Library)：标模板库&lt;/p&gt;
&lt;p&gt;广义：容器(container)、算法(algorithm)、迭代器(iterator)&lt;/p&gt;
&lt;p&gt;容器和算法之间通过迭代器无缝衔接&lt;/p&gt;
&lt;p&gt;STL几乎所有源码采用模板类或者模板</summary>
      
    
    
    
    <category term="C/C++" scheme="https://jiajunlen.github.io/category/C-C/"/>
    
    
    <category term="C/C++;STL" scheme="https://jiajunlen.github.io/tag/C-C-STL/"/>
    
  </entry>
  
  <entry>
    <title>类</title>
    <link href="https://jiajunlen.github.io/post/classbase/"/>
    <id>https://jiajunlen.github.io/post/classbase/</id>
    <published>2024-03-11T10:49:00.000Z</published>
    <updated>2024-03-12T14:10:02.403Z</updated>
    
    <content type="html"><![CDATA[<p>关于类（对象）的一些记录~~~</p><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>C语言是面向过程编程，而C++在C语言的基础上增加了OOP（面向对象编程），并且具备三大特性：</p><p><strong>封装</strong><br><strong>继承</strong><br><strong>多态</strong></p><p>类包含两部分内容：属性（名词）、方法（行为动作）</p><p>在类体中直接定义函数时，不需要在函数名前面加上类名，因为函数属于哪一个类是不言而喻的。<br>但当成员函数定义在类外时，就必须在函数名前面加上类名予以限定。<br>::被称为域解析符（也称作用域运算符或作用域限定符），用来连接类名和函数名，指明当前函数属于哪个类。<br>成员函数必须先在类体中作原型声明，然后在类外定义，也就是说类体的位置应在函数定义之前。</p><h2 id="1、类和对象"><a href="#1、类和对象" class="headerlink" title="1、类和对象"></a>1、类和对象</h2><p>类定义是以关键字 class 开头,后跟类的名称;类的主体是包含在一对花括号中;类定义后必须跟着一个分号或一个声明列表.<br>我们将一类事物的共同特性抽取出来，进行类的组合:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Animal</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    string sex;</span><br><span class="line">    int age;</span><br><span class="line">public:</span><br><span class="line">    Animal()&#123;</span><br><span class="line">        cout&lt;&lt;”这是构造”&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Animal()&#123;</span><br><span class="line">        cout&lt;&lt;”这是析构”&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">void speak() &#123;</span><br><span class="line">cout &lt;&lt; &quot;动物说话技能&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 创建对象</span><br><span class="line">Animal animal1;</span><br></pre></td></tr></table></figure><p>类是创建对象的模板，一个类可以创建多个对象，每个对象都是类类型的一个变量；创建对象的过程也叫类的实例化。与结构体一样，类只是一种复杂数据类型的声明，不占用内存空间。而对象是类这种数据类型的一个变量，或者说是通过类这种数据类型创建出来的一份实实在在的数据，所以占用内存空间。<br>关于构造和析构：<br>目前可以知道的就是：<strong>构造可以用来初始化变量，析构可以用来释放指针变量。</strong></p><h3 id="1-1-创建对象"><a href="#1-1-创建对象" class="headerlink" title="1.1 创建对象"></a>1.1 创建对象</h3><p>关于创建对象，数组和指针都可以；<br>new 在堆上创建出来的对象是匿名的，没法直接使用，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数。</p><p><strong>一般有两种创建对象的方式：</strong><br><strong>（1）在栈上创建，形式和定义普通变量类似；</strong><br><strong>（2）在堆上使用 new关键字创建，必须要用一个指针指向它，读者要记得 delete 掉不再使用的对象。</strong></p><h3 id="1-2-访问"><a href="#1-2-访问" class="headerlink" title="1.2 访问"></a>1.2 访问</h3><p><strong>（1）访问类成员</strong><br>创建对象以后，可以使用点号（.）来访问成员变量和成员函数，这和通过结构体变量来访问它的成员类似。<br>如果是指针变量，那么就需要使用箭头（-&gt;）来访问。类似于下面的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//创建对象</span><br><span class="line">Animal aml;</span><br><span class="line">aml.age = 15;</span><br><span class="line">aml.sex = &quot;boy&quot;;</span><br><span class="line">aml.speak();</span><br></pre></td></tr></table></figure><p><strong>（2）访问权限</strong><br>public：    公共的，那么是公共的就意味这不管是类内还是类外都是可以访问的。<br>protected： 受保护的，既然是被保护的对于类外来说也是不可以访问的。<br>private：   私有的，这个自然听得出来类外肯定是不可以访问的，只有类内是可以访问的。</p><p>protected和private这两个在继承的时候这两个是有区别的(后面提)。</p><h3 id="1-3-构造函数"><a href="#1-3-构造函数" class="headerlink" title="1.3 构造函数"></a>1.3 构造函数</h3><p>名字和类名相同，没有返回值，不需要用户显式调用（用户也不能调用），而是在创建对象时自动执行。</p><p>一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成。而自动生成的构造函数，这个构造函数的函数体是空的，也没有形参，也不执行任何操作。</p><p>但是有一个要特别记住，就是初始化const变量的时候，初始化 const 成员变量的唯一方法就是使用初始化列表。</p><h3 id="1-4-析构函数"><a href="#1-4-析构函数" class="headerlink" title="1.4 析构函数"></a>1.4 析构函数</h3><p>注意：析构函数没有参数，不能被重载，因此一个类只能有一个析构函数。如果用户没有定义，编译器会自动生成一个默认的析构函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">析构函数执行的时机</span><br><span class="line"></span><br><span class="line">在所有函数之外创建的对象是全局对象，它和全局变量类似，位于内存分区中的全局数据区，程序在结束执行时会调用这些对象的析构函数。</span><br><span class="line">在函数内部创建的对象是局部对象，它和局部变量类似，位于栈区，函数执行结束时会调用这些对象的析构函数。</span><br><span class="line">new 创建的对象位于堆区，通过 delete 删除时才会调用析构函数；如果没有 delete，析构函数就不会被执行。</span><br></pre></td></tr></table></figure><h3 id="1-5-this指针"><a href="#1-5-this指针" class="headerlink" title="1.5 this指针"></a>1.5 this指针</h3><p>this 是 C++ 中的一个关键字，也是一个 const 指针，它指向当前对象，通过它可以访问当前对象的所有成员。</p><p>this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this。它是成员函数和成员变量关联的桥梁。</p><h3 id="1-6-静态成员变量"><a href="#1-6-静态成员变量" class="headerlink" title="1.6 静态成员变量"></a>1.6 静态成员变量</h3><p>在C++中，我们可以使用静态成员变量来实现多个对象共享数据的目标。静态成员变量是一种特殊的成员变量，它被关键字static修饰<br>static 成员变量既可以通过对象来访问，也可以通过类来访问。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注意1：static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的</span><br><span class="line">static 成员变量不能使用。</span><br><span class="line"></span><br><span class="line">注意2：static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问，只要你在类外有进行初始化。具体来说，static 成员变量和普通的 static 变量类似，都在内存分区中的全局数据区分配内存。</span><br></pre></td></tr></table></figure><p>使用静态变量注意下面几点：</p><p>①一个类中可以有一个或多个静态成员变量，所有的对象都共享这些静态成员变量，都可以引用它。<br>②static 成员变量和普通 static 变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。<br>③静态成员变量必须初始化，而且只能在类体外进行。<br>④静态成员变量既可以通过对象名访问，也可以通过类名访问，但要遵循 private、protected 和 public 关键字的访问权限限制。当通过对象名访问时，对于不同的对象，访问的是同一份内存。</p><h3 id="1-7-静态成员函数"><a href="#1-7-静态成员函数" class="headerlink" title="1.7 静态成员函数"></a>1.7 静态成员函数</h3><p>普通成员函数可以访问所有成员（包括成员变量和成员函数），静态成员函数只能访问静态成员。</p><p>编译器在编译一个普通成员函数时，会隐式地增加一个形参 this，并把当前对象的地址赋值给 this，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。而静态成员函数可以通过类来直接调用，编译器不会为它增加形参 this，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。</p><p>普通成员变量占用对象的内存，静态成员函数没有 this 指针，不知道指向哪个对象，无法访问对象的成员变量，也就是说静态成员函数不能访问普通成员变量，只能访问静态成员变量。</p><h3 id="1-8-const成员函数"><a href="#1-8-const成员函数" class="headerlink" title="1.8 const成员函数"></a>1.8 const成员函数</h3><p>const 成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要还是为了保护数据而设置的。const 成员函数也称为常成员函数。我们通常将 get 函数设置为常成员函数。读取成员变量的函数的名字通常以get开头，后跟成员变量的名字，所以通常将它们称为 get 函数。常成员函数需要在声明和定义的时候在函数头部的结尾加上 const 关键字。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">最后强调一下，const位置不同，那么对应的含义也不同：</span><br><span class="line"></span><br><span class="line">函数开头的 const 用来修饰函数的返回值，表示返回值是 const 类型，也就是不能被修改</span><br><span class="line">例如const char * getname()。</span><br><span class="line"></span><br><span class="line">函数头部的结尾加上 const 表示常成员函数，这种函数只能读取成员变量的值，而不能修改成员变量的值</span><br><span class="line">例如char * getname() const。</span><br></pre></td></tr></table></figure><h2 id="2、继承"><a href="#2、继承" class="headerlink" title="2、继承"></a>2、继承</h2><h2 id="3、多态与虚函数"><a href="#3、多态与虚函数" class="headerlink" title="3、多态与虚函数"></a>3、多态与虚函数</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于类（对象）的一些记录~~~&lt;/p&gt;
&lt;h1 id=&quot;类&quot;&gt;&lt;a href=&quot;#类&quot; class=&quot;headerlink&quot; title=&quot;类&quot;&gt;&lt;/a&gt;类&lt;/h1&gt;&lt;p&gt;C语言是面向过程编程，而C++在C语言的基础上增加了OOP（面向对象编程），并且具备三大特性：&lt;/p&gt;</summary>
      
    
    
    
    <category term="C/C++" scheme="https://jiajunlen.github.io/category/C-C/"/>
    
    
    <category term="C/C++;类" scheme="https://jiajunlen.github.io/tag/C-C-%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>C/C++基础</title>
    <link href="https://jiajunlen.github.io/post/cppbase/"/>
    <id>https://jiajunlen.github.io/post/cppbase/</id>
    <published>2024-03-11T02:19:50.000Z</published>
    <updated>2024-03-20T08:42:27.577Z</updated>
    
    <content type="html"><![CDATA[<p>C&#x2F;C++基本知识的学习</p><h1 id="1、C-语法"><a href="#1、C-语法" class="headerlink" title="1、C++语法"></a>1、C++语法</h1><h2 id="1、基础知识"><a href="#1、基础知识" class="headerlink" title="1、基础知识"></a>1、基础知识</h2><h3 id="1-1-标准输入、输出"><a href="#1-1-标准输入、输出" class="headerlink" title="1.1 标准输入、输出"></a>1.1 标准输入、输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;    //标准输入输出流头文件</span><br><span class="line">using namespace std;  //展开标准库命名空间std</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 标准输入</span><br><span class="line">    cin &gt;&gt; &quot;a&quot;;</span><br><span class="line">    // 标准输出</span><br><span class="line">    cout &lt;&lt; &quot;字符串内容&quot; &lt;&lt; 变量、表达式 &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-注释"><a href="#1-2-注释" class="headerlink" title="1.2 注释"></a>1.2 注释</h3><p>（1）单行注释 <code>//</code><br>（2）多行注释 <code>/**/</code></p><h3 id="1-3-变量"><a href="#1-3-变量" class="headerlink" title="1.3 变量"></a>1.3 变量</h3><p>定义：数据类型  变量名 &#x3D; 初值</p><h3 id="1-4-常量"><a href="#1-4-常量" class="headerlink" title="1.4 常量"></a>1.4 常量</h3><p>（1）#define  ~宏常量<br>（2）const    ~const常量<br>不能修改，报错</p><h3 id="1-5-关键字"><a href="#1-5-关键字" class="headerlink" title="1.5 关键字"></a>1.5 关键字</h3><p>不能作为变量名</p><h2 id="2、数据类型"><a href="#2、数据类型" class="headerlink" title="2、数据类型"></a>2、数据类型</h2><h3 id="2-1-整型"><a href="#2-1-整型" class="headerlink" title="2.1 整型"></a>2.1 整型</h3><table><thead><tr><th>数据类型</th><th>占用空间</th><th>取值范围</th></tr></thead><tbody><tr><td>short</td><td>2字节</td><td>-2^15~2^15-1</td></tr><tr><td>int</td><td>4字节</td><td>-2^31~2^31-1</td></tr><tr><td>long</td><td>win 4字节;Linux 4(32位)、8(64位)</td><td>-2^31~2^31-1</td></tr><tr><td>long long</td><td>8字节</td><td>-2^63~2^63-1</td></tr></tbody></table><h3 id="2-2-sizeof"><a href="#2-2-sizeof" class="headerlink" title="2.2 sizeof()"></a>2.2 sizeof()</h3><p>sizeof(变量&#x2F;数据类型)，返回字节数</p><h3 id="2-3-浮点型"><a href="#2-3-浮点型" class="headerlink" title="2.3 浮点型"></a>2.3 浮点型</h3><table><thead><tr><th>数据类型</th><th>占用空间</th><th>取值范围</th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>-2^128~2^128(实际精度6-7位)</td></tr><tr><td>double</td><td>8字节</td><td>-2^1024~2^1024(实际精度15-16位)</td></tr></tbody></table><p>无论哪种打印时都只显示6位有效数字</p><h3 id="2-4-字符型"><a href="#2-4-字符型" class="headerlink" title="2.4 字符型"></a>2.4 字符型</h3><p>占用1字节空间，并不是把字符本身放入内存存储，而是将对应ASCII码放入存储单元<br><code>(int)字符 --&gt; 可以打印对应ASCII值</code><br>注意：<br>（1）创建时单引号<br>（2）单引号内只能一个字符</p><h3 id="2-5-转移字符"><a href="#2-5-转移字符" class="headerlink" title="2.5 转移字符"></a>2.5 转移字符</h3><p>常见如下：<br>（1）\n 换行<br>（2）\\ 转义输出一个\<br>（3）\t 水平制表符</p><h3 id="2-6-字符串"><a href="#2-6-字符串" class="headerlink" title="2.6 字符串"></a>2.6 字符串</h3><p>（1）C风格：<code>char 变量名[] = &quot;字符串值&quot;; // 中括号、双引号</code><br>（2）C++风格：<code>string 变量名 = &quot;字符串值&quot;; //需要字符串头文件</code></p><h3 id="2-7-bool"><a href="#2-7-bool" class="headerlink" title="2.7 bool"></a>2.7 bool</h3><p>只占1字节空间， true | false 本质 1 | 0</p><h2 id="3、运算符"><a href="#3、运算符" class="headerlink" title="3、运算符"></a>3、运算符</h2><h3 id="3-1-算术运算符"><a href="#3-1-算术运算符" class="headerlink" title="3.1 算术运算符"></a>3.1 算术运算符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a = 1, b = 2; c;</span><br><span class="line">c = a + b; //加</span><br><span class="line">c = b - a; //减</span><br><span class="line">c = a * b; //乘</span><br><span class="line">c = a / d; //除以</span><br><span class="line">c = a % d; //取余 </span><br></pre></td></tr></table></figure><h3 id="3-2-赋值运算符"><a href="#3-2-赋值运算符" class="headerlink" title="3.2 赋值运算符"></a>3.2 赋值运算符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">a = 2; //赋值</span><br><span class="line">c += 2; </span><br><span class="line">c -= 1; </span><br><span class="line">c *= 3; </span><br><span class="line">c /= 4; </span><br></pre></td></tr></table></figure><h3 id="3-3-比较运算符"><a href="#3-3-比较运算符" class="headerlink" title="3.3 比较运算符"></a>3.3 比较运算符</h3><p>大于、小于、等于、不等于、大于等于、小于等于等等；<br>结果只有两个： 0 或 1</p><h3 id="3-4-逻辑表达式"><a href="#3-4-逻辑表达式" class="headerlink" title="3.4 逻辑表达式"></a>3.4 逻辑表达式</h3><p>与(&amp;&amp;)、或(||)、非(!)</p><h3 id="3-5-三目运算符"><a href="#3-5-三目运算符" class="headerlink" title="3.5 三目运算符"></a>3.5 三目运算符</h3><p>语法： 表达式1 ？ 表达式2 ：表达式3；<br>可左值也可右值</p><h2 id="4、语句"><a href="#4、语句" class="headerlink" title="4、语句"></a>4、语句</h2><h3 id="4-1-if"><a href="#4-1-if" class="headerlink" title="4.1 if"></a>4.1 if</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(条件1)&#123;执行语句&#125;</span><br><span class="line">else if(条件2)&#123;执行语句&#125;</span><br><span class="line">else&#123;以上都不满足，执行此语句&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-for"><a href="#4-2-for" class="headerlink" title="4.2 for"></a>4.2 for</h3><p>语法： <code>for(起始表达式;条件表达式;末尾循环体)&#123;循环体&#125;</code></p><h3 id="4-3-while"><a href="#4-3-while" class="headerlink" title="4.3 while"></a>4.3 while</h3><p>（1）<code>while (循环条件)&#123;循环体&#125;</code><br>（2）<code>do &#123;循环体&#125; while (循环条件)</code></p><h3 id="4-4-switch"><a href="#4-4-switch" class="headerlink" title="4.4 switch"></a>4.4 switch</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">switch(表达式) //表达式：整型、字符型等</span><br><span class="line">&#123;</span><br><span class="line">    case 1: 执行语句1;break;</span><br><span class="line">    case 2: 执行语句2;break;</span><br><span class="line">    ......</span><br><span class="line">    default: 执行语句;break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、数组"><a href="#5、数组" class="headerlink" title="5、数组"></a>5、数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//定义</span><br><span class="line">数据类型 数组名[数组长度];</span><br><span class="line">数据类型 数组名[] = &#123;值1,值2,...&#125;;</span><br><span class="line">数据类型 数组名[数组长度] = &#123;值1,值2,...&#125;;</span><br><span class="line">//计算每个元素占用大小</span><br><span class="line">sizeof(数组名[0]);</span><br><span class="line">//计算元素个数</span><br><span class="line">sizeof(数组名)/sizeof(数组名[0]);</span><br></pre></td></tr></table></figure><h2 id="6、指针"><a href="#6、指针" class="headerlink" title="6、指针"></a>6、指针</h2><p>作用：间接访问内存<br>（1）内存编号从0开始，十六进制表示；<br>（2）指针变量存放的是一个地址</p><p>32位：4字节<br>64位：8字节</p><h3 id="6-1-空指针"><a href="#6-1-空指针" class="headerlink" title="6.1 空指针"></a>6.1 空指针</h3><p>用于给指针变量初始化，不可访问：NULL为0，而0~255之间的内存编号是系统占用</p><h3 id="6-2-野指针"><a href="#6-2-野指针" class="headerlink" title="6.2 野指针"></a>6.2 野指针</h3><p>指向非法内存空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *p = (int *)0x1100;   //十六进制数强转为地址</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;       //访问野指针报错</span><br></pre></td></tr></table></figure><h3 id="6-3-new-操作符"><a href="#6-3-new-操作符" class="headerlink" title="6.3 new 操作符"></a>6.3 <goto id="63">new 操作符</goto></h3><p>C++利用new操作符在堆区开辟数据空间（程序员手动操作）<br>释放利用操作符delete</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//语法：new 数据类型</span><br><span class="line">//返回该数据对应类型的指针</span><br><span class="line"></span><br><span class="line">//1、new的基本语法</span><br><span class="line">int * func()</span><br><span class="line">&#123;</span><br><span class="line">    //在堆区创建整型数据</span><br><span class="line">    int *p = new int(10);</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line">//2、调用函数</span><br><span class="line">int *p = func();</span><br><span class="line">//3、释放</span><br><span class="line">delete p;</span><br><span class="line">//内存释放后，再次访问即非法访问</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 1、在堆区利用new开辟数组</span><br><span class="line">int * arr = new int[10]; //10代表数组有10个元素</span><br><span class="line">for(int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">    arr[i] = i + 100; //10个地址赋值</span><br><span class="line">&#125;</span><br><span class="line">//2、释放</span><br><span class="line">delete[] arr; //需要加[]</span><br></pre></td></tr></table></figure><h2 id="7、函数"><a href="#7、函数" class="headerlink" title="7、函数"></a>7、函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//声明</span><br><span class="line">返回值类型 函数名 (参数列表);</span><br><span class="line">//定义</span><br><span class="line">返回值类型 函数名 (参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    函数语句;</span><br><span class="line">    return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、结构体"><a href="#8、结构体" class="headerlink" title="8、结构体"></a>8、结构体</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct 结构体名 &#123;成员列表&#125;;</span><br><span class="line">//创建变量</span><br><span class="line">struct 结构体名 变量名;</span><br><span class="line">struct 结构体名 变量名 = &#123;成员1初值,成员2初值,...&#125;;</span><br></pre></td></tr></table></figure><h1 id="2、核心"><a href="#2、核心" class="headerlink" title="2、核心"></a>2、核心</h1><h2 id="2-1内存分区"><a href="#2-1内存分区" class="headerlink" title="2.1内存分区"></a>2.1内存分区</h2><p>代码区：存放函数体的二进制代码，由操作系统进行管理的；<br>全局区：存放全局变量和静态变量以及常量；<br>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等；<br>堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。</p><p>不同区存放的数据，具备不同的生命周期，对于灵活编程意义重大</p><h3 id="（1）程序运行前"><a href="#（1）程序运行前" class="headerlink" title="（1）程序运行前"></a>（1）程序运行前</h3><p>在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域</p><p><strong>代码区:</strong><br>存放 CPU 执行的机器指令<br>代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可<br>代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p><p><strong>全局区:</strong><br>全局变量和静态变量存放在此<br>全局区还包含了常量区,字符串常量和其他常量也存放在此(全局常量)<br><code>该区域的数据在程序结束后由操作系统释放</code></p><p>注意：局部常量不在全局区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">总结:</span><br><span class="line">1、C++中在程序运行前分为全局区和代码区</span><br><span class="line">2、代码区特点是共享和只读</span><br><span class="line">3、全局区中存放全局变量、静态变量、常量</span><br><span class="line">4、常量区中存放 const修饰的全局常量 和 字符串常量</span><br></pre></td></tr></table></figure><h3 id="（2）程序运行后"><a href="#（2）程序运行后" class="headerlink" title="（2）程序运行后"></a>（2）程序运行后</h3><p><strong>栈区：</strong><br>由编译器自动分配释放，存放函数的参数值、局部变量等；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意事项：</span><br><span class="line">不要返回局部变量的地址，栈区开辟的数据由编译器自动释放。</span><br></pre></td></tr></table></figure><p><strong>堆区：</strong><br>由程序员分配释放，若不释放，程序结束时由操作系统回收；<br>在C++中主要利用new在堆区开辟释放。</p><p>若想在堆区开辟内存，需要对<a href="#63">new操作符</a>有所了解</p><h2 id="2-2-引用"><a href="#2-2-引用" class="headerlink" title="2.2 引用"></a>2.2 引用</h2><p><strong>本质：</strong>在C++内部实现是一个指针常量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">作用：给变量起别名</span><br><span class="line">语法：数据类型 &amp;别名 = 原名</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//1、引用必须初始化</span><br><span class="line">//int &amp;b; //错误</span><br><span class="line">//2、引用初始化后，不可更改别名</span><br><span class="line">int a = 10,c = 20;</span><br><span class="line">int &amp;b = a; </span><br><span class="line">b = c; //赋值操作，a、b、c均赋值为20</span><br></pre></td></tr></table></figure><h3 id="（1）引用-函数参数"><a href="#（1）引用-函数参数" class="headerlink" title="（1）引用-&gt;函数参数"></a>（1）引用-&gt;函数参数</h3><p><strong>作用：</strong>形参修饰实参<br><strong>优点：</strong>简化指针修改实参操作（地址传参、引用传参）</p><h3 id="（2）引用-函数返回值"><a href="#（2）引用-函数返回值" class="headerlink" title="（2）引用-&gt;函数返回值"></a>（2）引用-&gt;函数返回值</h3><p><strong>注意：</strong>不可返回局部变量引用<br><strong>用法：</strong>函数调用作为左值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int&amp; test()</span><br><span class="line">&#123;</span><br><span class="line">    static int a = 10; //静态变量，存放全局区</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br><span class="line">int &amp;ref = test();</span><br><span class="line">test() = 1000;  // a = 1000; ref = 1000;</span><br></pre></td></tr></table></figure><h3 id="3-左值、右值引用"><a href="#3-左值、右值引用" class="headerlink" title="(3) 左值、右值引用"></a>(3) 左值、右值引用</h3><p>引用：别名、声明时必须初始化、通过引用修改变量值</p><p>const左值引用能指向右值：局限是不能修改这个值</p><p>右值引用通过std::move()可以指向左值</p><p>申明出来的引用变量都是左值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int &amp;&amp; j = 10; // j是左值</span><br><span class="line">int &amp; k = 10;  // k是左值</span><br></pre></td></tr></table></figure><p><strong>左值引用  –&gt;</strong>  </p><p><strong>左值：</strong>可以放等号左边或右边、能取地址、具名的<br><code>变量名、返回左值引用的函数调用、前置自增/自减、赋值运算或符合赋值运算、解引用</code></p><p>避免对象拷贝</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数传参</span><br><span class="line">test(int&amp; param);</span><br><span class="line">函数返回值</span><br></pre></td></tr></table></figure><p><strong>右值引用  –&gt;</strong></p><p><strong>右值：</strong>只能在等号右边、不能取地址、不具名</p><p><strong>纯右值</strong><br>字面值：int i &#x3D; 10; &#x2F;&#x2F; 10就是纯右值<br>返回非引用类型的函数调用：<br>T  t &#x3D; CreateT();  &#x2F;&#x2F; CreateT()该函数是纯右值<br>后置自增&#x2F;自减：<br>算术表达式：<br>逻辑表达式：<br>比较表达式：<br>……<br><strong>将亡值</strong><br>C++11新引入的与右值引用（移动语义）相关的值类型<br>将亡值用来触发移动构造或移动赋值构造，并进行资源转移，之后将调用析构函数</p><p><strong>①实现移动语义</strong></p><p><em><strong>解决对象赋值时，避免资源重新分配；</strong></em><br><em><strong>移动构造以及移动拷贝构造；</strong></em><br><em><strong>STL应用广泛；</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 赋值</span><br><span class="line">A a,b;</span><br><span class="line">a = b;</span><br><span class="line">// 拷贝</span><br><span class="line">A a;</span><br><span class="line">A b(a); </span><br><span class="line">// 若A中有堆内存，深拷贝涉及到资源重新分配，移动语音就是解决此问题，提升效率,不用重新开辟内存</span><br><span class="line"></span><br><span class="line">A(A&amp;&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;p = a.p;</span><br><span class="line">    a.p = nullptr;</span><br><span class="line">    cout &lt;&lt; &quot;A(A&amp;&amp;)&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;A&gt; aList;</span><br><span class="line">aList.push_back(A());  //A()是右值，不具名，临时对象</span><br><span class="line">auto &amp;ele = alist.front();</span><br></pre></td></tr></table></figure><p><strong>②实现完美转发</strong><br><em><strong>函数模板可以将自己的参数完美转发给内部调用其它函数；</strong></em><br><em><strong>完美不仅能准确的转发参数的值，还能保证被转发的参数的左右值属性不变；</strong></em><br><em><strong>借用万能引用，通过引用方式接收左右属性的值；</strong></em><br><em><strong>引用折叠规则：参数为左值或左值引用，T&amp;&amp;将转化为int&amp;;参数为右值或右值引用，T&amp;&amp;将转换为int&amp;&amp;。</strong></em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void func(int &amp;n)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;左值&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void func(int &amp;&amp;n)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;右值&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void revoke(T &amp;&amp;t)</span><br><span class="line">&#123;</span><br><span class="line">    func(forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;C&amp;#x2F;C++基本知识的学习&lt;/p&gt;
&lt;h1 id=&quot;1、C-语法&quot;&gt;&lt;a href=&quot;#1、C-语法&quot; class=&quot;headerlink&quot; title=&quot;1、C++语法&quot;&gt;&lt;/a&gt;1、C++语法&lt;/h1&gt;&lt;h2 id=&quot;1、基础知识&quot;&gt;&lt;a href=&quot;#1、基础</summary>
      
    
    
    
    <category term="C/C++" scheme="https://jiajunlen.github.io/category/C-C/"/>
    
    
    <category term="C/C++;" scheme="https://jiajunlen.github.io/tag/C-C/"/>
    
  </entry>
  
  <entry>
    <title>动态链接库</title>
    <link href="https://jiajunlen.github.io/post/dynamicLinkedLibrary/"/>
    <id>https://jiajunlen.github.io/post/dynamicLinkedLibrary/</id>
    <published>2024-03-10T08:45:02.000Z</published>
    <updated>2024-03-20T08:33:51.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>简单了解一下<br>动态链接库（Dynamic Link Library 或者 Dynamic-link Library，缩写为 DLL）</p><h1 id="VS2019-Win10"><a href="#VS2019-Win10" class="headerlink" title="VS2019 + Win10"></a>VS2019 + Win10</h1><p><img src="/post/dynamicLinkedLibrary/1.png" alt="架构图"></p><h1 id="QT-Win10"><a href="#QT-Win10" class="headerlink" title="QT + Win10"></a>QT + Win10</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;简单了解一下&lt;br&gt;动态链接库（Dynamic Link Library 或者 Dynamic-link Library，缩写为 DLL）&lt;</summary>
      
    
    
    
    <category term="dll" scheme="https://jiajunlen.github.io/category/dll/"/>
    
    
    <category term="C/C++;Qt;windows;" scheme="https://jiajunlen.github.io/tag/C-C-Qt-windows/"/>
    
  </entry>
  
  <entry>
    <title>学习规划</title>
    <link href="https://jiajunlen.github.io/post/learn/"/>
    <id>https://jiajunlen.github.io/post/learn/</id>
    <published>2024-03-08T10:00:00.000Z</published>
    <updated>2024-03-11T02:22:07.726Z</updated>
    
    <content type="html"><![CDATA[<p>  这里是学习的一些记录随笔，做项目时顺便巩固知识！在此处做个记录~~~</p><h1 id="1、C-语法"><a href="#1、C-语法" class="headerlink" title="1、C++语法"></a>1、C++语法</h1><h2 id="1、基础知识"><a href="#1、基础知识" class="headerlink" title="1、基础知识"></a>1、基础知识</h2><h3 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h3><p>基本数据类型<br>构造类型<br>指针<br>引用变量</p><h3 id="2、运算符"><a href="#2、运算符" class="headerlink" title="2、运算符"></a>2、运算符</h3><h3 id="3、流程结构"><a href="#3、流程结构" class="headerlink" title="3、流程结构"></a>3、流程结构</h3><h3 id="4、函数"><a href="#4、函数" class="headerlink" title="4、函数"></a>4、函数</h3><p>申明、定义<br>函数类型<br>函数指针<br>函数重载<br>递归</p><h3 id="5、文件操作"><a href="#5、文件操作" class="headerlink" title="5、文件操作"></a>5、文件操作</h3><h3 id="6、内存管理"><a href="#6、内存管理" class="headerlink" title="6、内存管理"></a>6、内存管理</h3><h2 id="2、类"><a href="#2、类" class="headerlink" title="2、类"></a>2、类</h2><p>封装、继承、多态</p><h3 id="1、类和对象"><a href="#1、类和对象" class="headerlink" title="1、类和对象"></a>1、类和对象</h3><h3 id="2、类实例"><a href="#2、类实例" class="headerlink" title="2、类实例"></a>2、类实例</h3><h3 id="3、继承"><a href="#3、继承" class="headerlink" title="3、继承"></a>3、继承</h3><h3 id="4、多态与虚函数"><a href="#4、多态与虚函数" class="headerlink" title="4、多态与虚函数"></a>4、多态与虚函数</h3><h2 id="3、模版"><a href="#3、模版" class="headerlink" title="3、模版"></a>3、模版</h2><h3 id="1、函数模版"><a href="#1、函数模版" class="headerlink" title="1、函数模版"></a>1、函数模版</h3><h3 id="2、类模版"><a href="#2、类模版" class="headerlink" title="2、类模版"></a>2、类模版</h3><h3 id="3、继承的模版"><a href="#3、继承的模版" class="headerlink" title="3、继承的模版"></a>3、继承的模版</h3><h3 id="4、多态的模版"><a href="#4、多态的模版" class="headerlink" title="4、多态的模版"></a>4、多态的模版</h3><h2 id="4、STL"><a href="#4、STL" class="headerlink" title="4、STL"></a>4、STL</h2><h2 id="5、新特性11-14-17"><a href="#5、新特性11-14-17" class="headerlink" title="5、新特性11&#x2F;14&#x2F;17"></a>5、新特性11&#x2F;14&#x2F;17</h2><h2 id="6、对象模型"><a href="#6、对象模型" class="headerlink" title="6、对象模型"></a>6、对象模型</h2><h3 id="2、QT基础、控件、对话框"><a href="#2、QT基础、控件、对话框" class="headerlink" title="2、QT基础、控件、对话框"></a>2、QT基础、控件、对话框</h3><h3 id="QT进阶"><a href="#QT进阶" class="headerlink" title="QT进阶"></a>QT进阶</h3><h3 id="其他：QML、Qt-Quick、OPenCV"><a href="#其他：QML、Qt-Quick、OPenCV" class="headerlink" title="其他：QML、Qt Quick、OPenCV"></a>其他：QML、Qt Quick、OPenCV</h3><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h3 id="调试和测试：单步调试、QTestLib框架、日志（设计、实现、测试）"><a href="#调试和测试：单步调试、QTestLib框架、日志（设计、实现、测试）" class="headerlink" title="调试和测试：单步调试、QTestLib框架、日志（设计、实现、测试）"></a>调试和测试：单步调试、QTestLib框架、日志（设计、实现、测试）</h3><h3 id="项目-（涵盖以上知识、加密播放器、网络天气预报、海康威视萤石云）"><a href="#项目-（涵盖以上知识、加密播放器、网络天气预报、海康威视萤石云）" class="headerlink" title="项目 （涵盖以上知识、加密播放器、网络天气预报、海康威视萤石云）"></a>项目 （涵盖以上知识、加密播放器、网络天气预报、海康威视萤石云）</h3><h3 id="面试-（基础、项目）"><a href="#面试-（基础、项目）" class="headerlink" title="面试  （基础、项目）"></a>面试  （基础、项目）</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;  这里是学习的一些记录随笔，做项目时顺便巩固知识！在此处做个记录~~~&lt;/p&gt;
&lt;h1 id=&quot;1、C-语法&quot;&gt;&lt;a href=&quot;#1、C-语法&quot; class=&quot;headerlink&quot; title=&quot;1、C++语法&quot;&gt;&lt;/a&gt;1、C++语法&lt;/h1&gt;&lt;h2 id=&quot;1、基</summary>
      
    
    
    
    <category term="规划" scheme="https://jiajunlen.github.io/category/%E8%A7%84%E5%88%92/"/>
    
    
  </entry>
  
</feed>
