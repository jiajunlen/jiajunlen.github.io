{"meta":{"title":"一心向阳","subtitle":"心之所向，必有奇迹","description":null,"author":"len","url":"https://jiajunlen.github.io","root":"/"},"pages":[{"title":"错误页面","date":"2019-12-31T16:00:00.000Z","updated":"2024-03-08T12:59:49.208Z","comments":false,"path":"/404.html","permalink":"https://jiajunlen.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2024-03-08T10:00:00.000Z","updated":"2024-03-12T09:32:37.823Z","comments":false,"path":"about/index.html","permalink":"https://jiajunlen.github.io/about/index.html","excerpt":"","text":"关于我我是一个在命运长河里挣扎的小鱼，90后，目前是小白一枚。虽然心中不甘，但是目前确实是 Worst One 。目标是成为全栈工程师、系统架构师。虽然前路迷茫，但是我会一步一步往前走。"},{"title":"留言板","date":"2024-03-08T10:00:00.000Z","updated":"2024-03-08T13:52:08.887Z","comments":true,"path":"comment/index.html","permalink":"https://jiajunlen.github.io/comment/index.html","excerpt":"","text":""},{"title":"分类","date":"2024-03-08T10:00:00.000Z","updated":"2024-03-09T08:40:44.472Z","comments":true,"path":"category/index.html","permalink":"https://jiajunlen.github.io/category/index.html","excerpt":"","text":""},{"title":"赞赏","date":"2024-03-08T10:00:00.000Z","updated":"2024-03-08T13:55:48.190Z","comments":false,"path":"donate/index.html","permalink":"https://jiajunlen.github.io/donate/index.html","excerpt":"","text":"如果喜欢我的博客，或者喜欢我的博客主题，可以考虑赞赏一下哦，非常感激！网站所需的服务器和 CDN 都是不小的开支，日常维护也需要大量精力。 你们的支持是我前进的最大动力！"},{"title":"友情链接","date":"2024-03-08T10:00:00.000Z","updated":"2024-03-08T14:00:08.039Z","comments":false,"path":"friend/index.html","permalink":"https://jiajunlen.github.io/friend/index.html","excerpt":"","text":"欢迎各位朋友前来交换友链，本站友链接受以下类型的网站： 个人博客 公益组织等非盈利性网站 不接受广告、商业性网站，特殊情况除外 如果你的网站 一个月以上无法正常访问 将会被移除。"},{"title":"标签","date":"2024-03-08T10:00:00.000Z","updated":"2024-03-08T13:52:29.202Z","comments":true,"path":"tag/index.html","permalink":"https://jiajunlen.github.io/tag/index.html","excerpt":"","text":""}],"posts":[{"title":"socket-base-learn","slug":"socket-base-learn","date":"2024-03-13T08:37:06.000Z","updated":"2024-03-20T08:38:18.663Z","comments":true,"path":"post/socket/","permalink":"https://jiajunlen.github.io/post/socket/","excerpt":"","text":"xue","categories":[{"name":"网络编程","slug":"网络编程","permalink":"https://jiajunlen.github.io/category/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C/C++;socket","slug":"C-C-socket","permalink":"https://jiajunlen.github.io/tag/C-C-socket/"}]},{"title":"STL","slug":"STL-base-learn","date":"2024-03-13T07:14:11.000Z","updated":"2024-03-13T08:36:26.142Z","comments":true,"path":"post/stlbase/","permalink":"https://jiajunlen.github.io/post/stlbase/","excerpt":"","text":"STL(Standard Template Library)：标模板库 广义：容器(container)、算法(algorithm)、迭代器(iterator) 容器和算法之间通过迭代器无缝衔接 STL几乎所有源码采用模板类或者模板函数 1、STL六大组件容器、算法、迭代器、仿函数、适配器(配接器)、空间配置器 （1）容器：各种数据结构，如vector、list、deque、set、map等，用于存放数据（2）算法：各种常用算法，如sort、find、copy、for_each等（3）迭代器：容器与算法之间的粘合剂（4）仿函数：行为类似函数，可作为算法的某种策略（5）适配器：一种用来修饰容器或者仿函数或迭代器接口的东西（6）空间配置器：负责空间的配置与管理 1、容器算法迭代器1.1 容器常用的数据结构：数组、链表、树、栈、队列、集合、映射表等 序列式容器：强调值的排序，每个元素位置固定；关联式容器：二叉树结构，各元素之间无严格物理顺序关系 1.2 算法Algorithm 质变算法：运算过程中会更改区间内元素的内容。如：拷贝、替换、删除等等；非质变算法：运算过程中不会更改区间内的元素内容。如：查找、计数、遍历、寻找极值等等。 1.3 迭代器提供一种方法，使能够依序寻访某个容器所包含的各个元素，而又无需暴露该容器的内部表示方式。 每个容器都有自己专属迭代器 迭代器种类 种类 功能 支持运算 输入迭代器 对数据的只读访问 只读，支持++、–、！&#x3D; 输出迭代器 对数据的只写访问 只写，支持++ 前向迭代器 读写操作，并能向前推进迭代器 读写，支持++、&#x3D;&#x3D;、！&#x3D; 双向迭代器 读写操作，并能向前和向后操作 读写，支持++、– 随机访问迭代器 读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器 读写，支持++、–、[n]、-n、&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D; 常用：双向、随机 1.4 使用STL中最常用的容器vector,理解为数组 1.4.1 vector容器： vector算法： for_each迭代器：vector&lt;int&gt;::iterator 实例 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt; // 标准算法头文件using namespace std;void vPrint(int val)&#123; cout &lt;&lt; val &lt;&lt; endl;&#125;int main()&#123; vector&lt;int&gt; v; v.push_back(10); v.push_back(20); v.push_back(30); v.push_back(40); vector&lt;int&gt;::iterator itBegin = v.begin(); //起始迭代器，指向容器第一个元素 vector&lt;int&gt;::iterator itEnd = v.end(); //结束迭代器，指向容器中最后一个元素的下一个位置 // 第一种遍历方式 while(itBegin != itEnd) &#123; cout &lt;&lt; *itBegin &lt;&lt; endl; itBegin++; &#125; // 第二种遍历方式 for(vector&lt;int&gt;::iteator it = v.begin(); it != v.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; endl; &#125; // 第三种遍历方式 利用STL提供遍历算法,头文件algorithm for_each(v.begin(),v.end(),vPrint); // vPrint利用回调函数&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://jiajunlen.github.io/category/C-C/"}],"tags":[{"name":"C/C++;STL","slug":"C-C-STL","permalink":"https://jiajunlen.github.io/tag/C-C-STL/"}]},{"title":"类","slug":"class-base-learn","date":"2024-03-11T10:49:00.000Z","updated":"2024-03-12T14:10:02.403Z","comments":true,"path":"post/classbase/","permalink":"https://jiajunlen.github.io/post/classbase/","excerpt":"","text":"关于类（对象）的一些记录~~~ 类C语言是面向过程编程，而C++在C语言的基础上增加了OOP（面向对象编程），并且具备三大特性： 封装继承多态 类包含两部分内容：属性（名词）、方法（行为动作） 在类体中直接定义函数时，不需要在函数名前面加上类名，因为函数属于哪一个类是不言而喻的。但当成员函数定义在类外时，就必须在函数名前面加上类名予以限定。::被称为域解析符（也称作用域运算符或作用域限定符），用来连接类名和函数名，指明当前函数属于哪个类。成员函数必须先在类体中作原型声明，然后在类外定义，也就是说类体的位置应在函数定义之前。 1、类和对象类定义是以关键字 class 开头,后跟类的名称;类的主体是包含在一对花括号中;类定义后必须跟着一个分号或一个声明列表.我们将一类事物的共同特性抽取出来，进行类的组合: 12345678910111213141516171819class Animal&#123;private: string sex; int age;public: Animal()&#123; cout&lt;&lt;”这是构造”&lt;&lt;endl; &#125; ~Animal()&#123; cout&lt;&lt;”这是析构”&lt;&lt;endl; &#125; void speak() &#123; cout &lt;&lt; &quot;动物说话技能&quot; &lt;&lt; endl; &#125;&#125;;// 创建对象Animal animal1; 类是创建对象的模板，一个类可以创建多个对象，每个对象都是类类型的一个变量；创建对象的过程也叫类的实例化。与结构体一样，类只是一种复杂数据类型的声明，不占用内存空间。而对象是类这种数据类型的一个变量，或者说是通过类这种数据类型创建出来的一份实实在在的数据，所以占用内存空间。关于构造和析构：目前可以知道的就是：构造可以用来初始化变量，析构可以用来释放指针变量。 1.1 创建对象关于创建对象，数组和指针都可以；new 在堆上创建出来的对象是匿名的，没法直接使用，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数。 一般有两种创建对象的方式：（1）在栈上创建，形式和定义普通变量类似；（2）在堆上使用 new关键字创建，必须要用一个指针指向它，读者要记得 delete 掉不再使用的对象。 1.2 访问（1）访问类成员创建对象以后，可以使用点号（.）来访问成员变量和成员函数，这和通过结构体变量来访问它的成员类似。如果是指针变量，那么就需要使用箭头（-&gt;）来访问。类似于下面的方式： 12345//创建对象Animal aml;aml.age = 15;aml.sex = &quot;boy&quot;;aml.speak(); （2）访问权限public： 公共的，那么是公共的就意味这不管是类内还是类外都是可以访问的。protected： 受保护的，既然是被保护的对于类外来说也是不可以访问的。private： 私有的，这个自然听得出来类外肯定是不可以访问的，只有类内是可以访问的。 protected和private这两个在继承的时候这两个是有区别的(后面提)。 1.3 构造函数名字和类名相同，没有返回值，不需要用户显式调用（用户也不能调用），而是在创建对象时自动执行。 一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成。而自动生成的构造函数，这个构造函数的函数体是空的，也没有形参，也不执行任何操作。 但是有一个要特别记住，就是初始化const变量的时候，初始化 const 成员变量的唯一方法就是使用初始化列表。 1.4 析构函数注意：析构函数没有参数，不能被重载，因此一个类只能有一个析构函数。如果用户没有定义，编译器会自动生成一个默认的析构函数。 12345析构函数执行的时机在所有函数之外创建的对象是全局对象，它和全局变量类似，位于内存分区中的全局数据区，程序在结束执行时会调用这些对象的析构函数。在函数内部创建的对象是局部对象，它和局部变量类似，位于栈区，函数执行结束时会调用这些对象的析构函数。new 创建的对象位于堆区，通过 delete 删除时才会调用析构函数；如果没有 delete，析构函数就不会被执行。 1.5 this指针this 是 C++ 中的一个关键字，也是一个 const 指针，它指向当前对象，通过它可以访问当前对象的所有成员。 this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this。它是成员函数和成员变量关联的桥梁。 1.6 静态成员变量在C++中，我们可以使用静态成员变量来实现多个对象共享数据的目标。静态成员变量是一种特殊的成员变量，它被关键字static修饰static 成员变量既可以通过对象来访问，也可以通过类来访问。 1234注意1：static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的static 成员变量不能使用。注意2：static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问，只要你在类外有进行初始化。具体来说，static 成员变量和普通的 static 变量类似，都在内存分区中的全局数据区分配内存。 使用静态变量注意下面几点： ①一个类中可以有一个或多个静态成员变量，所有的对象都共享这些静态成员变量，都可以引用它。②static 成员变量和普通 static 变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。③静态成员变量必须初始化，而且只能在类体外进行。④静态成员变量既可以通过对象名访问，也可以通过类名访问，但要遵循 private、protected 和 public 关键字的访问权限限制。当通过对象名访问时，对于不同的对象，访问的是同一份内存。 1.7 静态成员函数普通成员函数可以访问所有成员（包括成员变量和成员函数），静态成员函数只能访问静态成员。 编译器在编译一个普通成员函数时，会隐式地增加一个形参 this，并把当前对象的地址赋值给 this，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。而静态成员函数可以通过类来直接调用，编译器不会为它增加形参 this，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。 普通成员变量占用对象的内存，静态成员函数没有 this 指针，不知道指向哪个对象，无法访问对象的成员变量，也就是说静态成员函数不能访问普通成员变量，只能访问静态成员变量。 1.8 const成员函数const 成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要还是为了保护数据而设置的。const 成员函数也称为常成员函数。我们通常将 get 函数设置为常成员函数。读取成员变量的函数的名字通常以get开头，后跟成员变量的名字，所以通常将它们称为 get 函数。常成员函数需要在声明和定义的时候在函数头部的结尾加上 const 关键字。 1234567最后强调一下，const位置不同，那么对应的含义也不同：函数开头的 const 用来修饰函数的返回值，表示返回值是 const 类型，也就是不能被修改例如const char * getname()。函数头部的结尾加上 const 表示常成员函数，这种函数只能读取成员变量的值，而不能修改成员变量的值例如char * getname() const。 2、继承3、多态与虚函数","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://jiajunlen.github.io/category/C-C/"}],"tags":[{"name":"C/C++;类","slug":"C-C-类","permalink":"https://jiajunlen.github.io/tag/C-C-%E7%B1%BB/"}]},{"title":"C/C++基础","slug":"cpp-base-learn","date":"2024-03-11T02:19:50.000Z","updated":"2024-03-20T08:29:46.039Z","comments":true,"path":"post/cppbase/","permalink":"https://jiajunlen.github.io/post/cppbase/","excerpt":"","text":"C&#x2F;C++基本知识的学习 1、C++语法1、基础知识1.1 标准输入、输出12345678910#include &lt;stdio.h&gt; //标准输入输出流头文件using namespace std; //展开标准库命名空间stdint main()&#123; // 标准输入 cin &gt;&gt; &quot;a&quot;; // 标准输出 cout &lt;&lt; &quot;字符串内容&quot; &lt;&lt; 变量、表达式 &lt;&lt; endl; return 0;&#125; 1.2 注释（1）单行注释 //（2）多行注释 /**/ 1.3 变量定义：数据类型 变量名 &#x3D; 初值 1.4 常量（1）#define ~宏常量（2）const ~const常量不能修改，报错 1.5 关键字不能作为变量名 2、数据类型2.1 整型 数据类型 占用空间 取值范围 short 2字节 -2^15~2^15-1 int 4字节 -2^31~2^31-1 long win 4字节;Linux 4(32位)、8(64位) -2^31~2^31-1 long long 8字节 -2^63~2^63-1 2.2 sizeof()sizeof(变量&#x2F;数据类型)，返回字节数 2.3 浮点型 数据类型 占用空间 取值范围 float 4字节 -2^128~2^128(实际精度6-7位) double 8字节 -2^1024~2^1024(实际精度15-16位) 无论哪种打印时都只显示6位有效数字 2.4 字符型占用1字节空间，并不是把字符本身放入内存存储，而是将对应ASCII码放入存储单元(int)字符 --&gt; 可以打印对应ASCII值注意：（1）创建时单引号（2）单引号内只能一个字符 2.5 转移字符常见如下：（1）\\n 换行（2）\\\\ 转义输出一个\\（3）\\t 水平制表符 2.6 字符串（1）C风格：char 变量名[] = &quot;字符串值&quot;; // 中括号、双引号（2）C++风格：string 变量名 = &quot;字符串值&quot;; //需要字符串头文件 2.7 bool只占1字节空间， true | false 本质 1 | 0 3、运算符3.1 算术运算符123456int a = 1, b = 2; c;c = a + b; //加c = b - a; //减c = a * b; //乘c = a / d; //除以c = a % d; //取余 3.2 赋值运算符123456int a = 1;a = 2; //赋值c += 2; c -= 1; c *= 3; c /= 4; 3.3 比较运算符大于、小于、等于、不等于、大于等于、小于等于等等；结果只有两个： 0 或 1 3.4 逻辑表达式与(&amp;&amp;)、或(||)、非(!) 3.5 三目运算符语法： 表达式1 ？ 表达式2 ：表达式3；可左值也可右值 4、语句4.1 if123if(条件1)&#123;执行语句&#125;else if(条件2)&#123;执行语句&#125;else&#123;以上都不满足，执行此语句&#125; 4.2 for语法： for(起始表达式;条件表达式;末尾循环体)&#123;循环体&#125; 4.3 while（1）while (循环条件)&#123;循环体&#125;（2）do &#123;循环体&#125; while (循环条件) 4.4 switch1234567switch(表达式) //表达式：整型、字符型等&#123; case 1: 执行语句1;break; case 2: 执行语句2;break; ...... default: 执行语句;break;&#125; 5、数组12345678//定义数据类型 数组名[数组长度];数据类型 数组名[] = &#123;值1,值2,...&#125;;数据类型 数组名[数组长度] = &#123;值1,值2,...&#125;;//计算每个元素占用大小sizeof(数组名[0]);//计算元素个数sizeof(数组名)/sizeof(数组名[0]); 6、指针作用：间接访问内存（1）内存编号从0开始，十六进制表示；（2）指针变量存放的是一个地址 32位：4字节64位：8字节 6.1 空指针用于给指针变量初始化，不可访问：NULL为0，而0~255之间的内存编号是系统占用 6.2 野指针指向非法内存空间 12int *p = (int *)0x1100; //十六进制数强转为地址cout &lt;&lt; *p &lt;&lt; endl; //访问野指针报错 6.3 new 操作符C++利用new操作符在堆区开辟数据空间（程序员手动操作）释放利用操作符delete 12345678910111213141516171819202122232425//语法：new 数据类型//返回该数据对应类型的指针//1、new的基本语法int * func()&#123; //在堆区创建整型数据 int *p = new int(10); return p;&#125;//2、调用函数int *p = func();//3、释放delete p;//内存释放后，再次访问即非法访问// 1、在堆区利用new开辟数组int * arr = new int[10]; //10代表数组有10个元素for(int i = 0; i &lt; 10; i++)&#123; arr[i] = i + 100; //10个地址赋值&#125;//2、释放delete[] arr; //需要加[] 7、函数12345678//声明返回值类型 函数名 (参数列表);//定义返回值类型 函数名 (参数列表)&#123; 函数语句; return 返回值;&#125; 8、结构体1234struct 结构体名 &#123;成员列表&#125;;//创建变量struct 结构体名 变量名;struct 结构体名 变量名 = &#123;成员1初值,成员2初值,...&#125;; 2、核心2.1内存分区代码区：存放函数体的二进制代码，由操作系统进行管理的；全局区：存放全局变量和静态变量以及常量；栈区：由编译器自动分配释放，存放函数的参数值，局部变量等；堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。 不同区存放的数据，具备不同的生命周期，对于灵活编程意义重大 （1）程序运行前在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域 代码区:存放 CPU 执行的机器指令代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令 全局区:全局变量和静态变量存放在此全局区还包含了常量区,字符串常量和其他常量也存放在此(全局常量)该区域的数据在程序结束后由操作系统释放 注意：局部常量不在全局区 12345总结:1、C++中在程序运行前分为全局区和代码区2、代码区特点是共享和只读3、全局区中存放全局变量、静态变量、常量4、常量区中存放 const修饰的全局常量 和 字符串常量 （2）程序运行后栈区：由编译器自动分配释放，存放函数的参数值、局部变量等； 12注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放。 堆区：由程序员分配释放，若不释放，程序结束时由操作系统回收；在C++中主要利用new在堆区开辟释放。 若想在堆区开辟内存，需要对new操作符有所了解 2.2 引用本质：在C++内部实现是一个指针常量。 12345678910作用：给变量起别名语法：数据类型 &amp;别名 = 原名//1、引用必须初始化//int &amp;b; //错误//2、引用初始化后，不可更改别名int a = 10,c = 20;int &amp;b = a; b = c; //赋值操作，a、b、c均赋值为20 （1）引用-&gt;函数参数作用：形参修饰实参优点：简化指针修改实参操作（地址传参、引用传参） （2）引用-&gt;函数返回值注意：不可返回局部变量引用用法：函数调用作为左值 1234567int&amp; test()&#123; static int a = 10; //静态变量，存放全局区 return a;&#125;int &amp;ref = test();test() = 1000; // a = 1000; ref = 1000; (3) 左值、右值引用引用：别名、声明时必须初始化、通过引用修改变量值 const左值引用能指向右值：局限是不能修改这个值 右值引用通过std::move()可以指向左值 申明出来的引用变量都是左值‘’’int &amp;&amp; j &#x3D; 10; &#x2F;&#x2F; j是左值int &amp; k &#x3D; 10; &#x2F;&#x2F; k是左值‘’’ 左值引用 –&gt; 左值：可以放等号左边或右边、能取地址、具名的‘’’变量名、返回左值引用的函数调用、前置自增&#x2F;自减、赋值运算或符合赋值运算、解引用’’’ 避免对象拷贝‘’’函数传参test(int&amp; param);函数返回值‘’’ 右值引用 –&gt; 右值：只能在等号右边、不能取地址、不具名 纯右值字面值：int i &#x3D; 10; &#x2F;&#x2F; 10就是纯右值返回非引用类型的函数调用：T t &#x3D; CreateT(); &#x2F;&#x2F; CreateT()该函数是纯右值后置自增&#x2F;自减：算术表达式：逻辑表达式：比较表达式：……将亡值C++11新引入的与右值引用（移动语义）相关的值类型将亡值用来触发移动构造或移动赋值构造，并进行资源转移，之后将调用析构函数 ①实现移动语义 解决对象赋值时，避免资源重新分配；移动构造以及移动拷贝构造；STL应用广泛；‘’’&#x2F;&#x2F; 赋值A a,b;a &#x3D; b;&#x2F;&#x2F; 拷贝A a;A b(a);&#x2F;&#x2F; 若A中有堆内存，深拷贝涉及到资源重新分配，移动语音就是解决此问题，提升效率,不用重新开辟内存 A(A&amp;&amp; a){ this-&gt;p &#x3D; a.p; a.p &#x3D; nullptr; cout &lt;&lt; “A(A&amp;&amp;)” &lt;&lt; endl;} List aList;aList.push_back(A()); &#x2F;&#x2F;A()是右值，不具名，临时对象auto &amp;ele &#x3D; alist.front();‘’’ ②实现完美转发函数模板可以将自己的参数完美转发给内部调用其它函数；完美不仅能准确的转发参数的值，还能保证被转发的参数的左右值属性不变；借用万能引用，通过引用方式接收左右属性的值；引用折叠规则：参数为左值或左值引用，T&amp;&amp;将转化为int&amp;;参数为右值或右值引用，T&amp;&amp;将转换为int&amp;&amp;。 ‘’’void func(int &amp;n){ cout &lt;&lt; “左值” &lt;&lt; endl;} void func(int &amp;&amp;n){ cout &lt;&lt; “右值” &lt;&lt; endl;} templatevoid revoke(T &amp;&amp;t){ func(forward(t));}‘’’","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://jiajunlen.github.io/category/C-C/"}],"tags":[{"name":"C/C++;","slug":"C-C","permalink":"https://jiajunlen.github.io/tag/C-C/"}]},{"title":"动态链接库","slug":"chat-demo-learn","date":"2024-03-10T08:45:02.000Z","updated":"2024-03-20T08:33:51.808Z","comments":true,"path":"post/dynamicLinkedLibrary/","permalink":"https://jiajunlen.github.io/post/dynamicLinkedLibrary/","excerpt":"","text":"简介简单了解一下动态链接库（Dynamic Link Library 或者 Dynamic-link Library，缩写为 DLL） VS2019 + Win10 QT + Win10","categories":[{"name":"dll","slug":"dll","permalink":"https://jiajunlen.github.io/category/dll/"}],"tags":[{"name":"C/C++;Qt;windows;","slug":"C-C-Qt-windows","permalink":"https://jiajunlen.github.io/tag/C-C-Qt-windows/"}]},{"title":"学习规划","slug":"hello-world","date":"2024-03-08T10:00:00.000Z","updated":"2024-03-11T02:22:07.726Z","comments":true,"path":"post/learn/","permalink":"https://jiajunlen.github.io/post/learn/","excerpt":"","text":"这里是学习的一些记录随笔，做项目时顺便巩固知识！在此处做个记录~~~ 1、C++语法1、基础知识1、数据类型基本数据类型构造类型指针引用变量 2、运算符3、流程结构4、函数申明、定义函数类型函数指针函数重载递归 5、文件操作6、内存管理2、类封装、继承、多态 1、类和对象2、类实例3、继承4、多态与虚函数3、模版1、函数模版2、类模版3、继承的模版4、多态的模版4、STL5、新特性11&#x2F;14&#x2F;176、对象模型2、QT基础、控件、对话框QT进阶其他：QML、Qt Quick、OPenCV设计模式调试和测试：单步调试、QTestLib框架、日志（设计、实现、测试）项目 （涵盖以上知识、加密播放器、网络天气预报、海康威视萤石云）面试 （基础、项目）","categories":[{"name":"规划","slug":"规划","permalink":"https://jiajunlen.github.io/category/%E8%A7%84%E5%88%92/"}],"tags":[]}],"categories":[{"name":"网络编程","slug":"网络编程","permalink":"https://jiajunlen.github.io/category/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"C/C++","slug":"C-C","permalink":"https://jiajunlen.github.io/category/C-C/"},{"name":"dll","slug":"dll","permalink":"https://jiajunlen.github.io/category/dll/"},{"name":"规划","slug":"规划","permalink":"https://jiajunlen.github.io/category/%E8%A7%84%E5%88%92/"}],"tags":[{"name":"C/C++;socket","slug":"C-C-socket","permalink":"https://jiajunlen.github.io/tag/C-C-socket/"},{"name":"C/C++;STL","slug":"C-C-STL","permalink":"https://jiajunlen.github.io/tag/C-C-STL/"},{"name":"C/C++;类","slug":"C-C-类","permalink":"https://jiajunlen.github.io/tag/C-C-%E7%B1%BB/"},{"name":"C/C++;","slug":"C-C","permalink":"https://jiajunlen.github.io/tag/C-C/"},{"name":"C/C++;Qt;windows;","slug":"C-C-Qt-windows","permalink":"https://jiajunlen.github.io/tag/C-C-Qt-windows/"}]}